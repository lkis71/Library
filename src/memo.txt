1. JPA를 사용하는 이유
- 단순한 CRUD의 무한 반복 해결
- SQL에 의존적이지 않는 객체 중심의 개발
- 패러다임의 불일치 해결
- 관계형DB와 달리 엔티티의 신뢰도가 높고, 자유로운 그래프 탐색이 가능
- 같은 트랜잭션 안에서는 같은 엔티티를 반환
	* 한 번 조회한 SQL을 두 번째부터의 같은 객체의 조회는 이미 조회한 데이터의 캐싱작용으로 SQL의 조회가 필요 없이 캐시(메모리)에 있는 데이터를 읽어온다.
	* 같은 트랜잭션 안에서 같은 엔티티의 조회가 여러번 이루질 때 SQL은 한 번만 실행한다.

2. 즉시로딩과 지연로딩
- 지연로딩: LAZY로 설정된 객체는 해당 객체의 초기화 시점(조회하는 시점)에 SQL을 실행한다.
- 즉시로딩: EAGER로 설정된 객체는 해당 객체가 필요로하지 않는 시점에도 SQL을 실행하여 가져온다.

3. JPA 내부 동작방식 이해
- Persistence(시작) -> EntityManagerFactory 실행 -> EntityManager 생성
- JPA의 모든 데이터 변경은 트랜잭션 안에서 이루어져야함
- 고객 요청시 EntityManagerFactory에서 EntityManger를 생성함

3-1. 영속성 컨텍스트
- 객체를 영구저장하는 환경
- 내부에 1차 캐시를 가지고 있음
- EntityManger를 통해서 영속성 컨텍스트(persistenceContext)에 접근함

3-2 버퍼링(persist시점에 SQL의 호출이 발생하지 않는 이유)
- 설정한 batch size만큼 영속성 컨텍스트를 모았다가 커밋시점에 SQL이 이루어진다.

3-3 변경감지(dirty checking)
- 1차캐시 안에 저장되어 있는 값과 스냅샷(값을 처음 읽어온 시점)을 비교
- flush 시점에 엔티티와 스냅샷의 값을 비교
- 변경된 값이 있으면 sql저장소에 값을 저장 후 DB에 커밋한다.

3-4 플러시
- 영속성 컨텍스트의 변경내용을 DB에 동기화
- 영속성 컨텍스트를 비우지 않음
- 트랜잭션이 끝나기 전(커밋 전)에만 동기화하면 됨

3-5 준영속성 컨텍스트
- persist이후 detach, clear, close등 함수를 사용하여 DB까지 가지 않고 1차 캐시에서만 관리할 수 있는 상태

4. 엔티티
- 기본 생성자 필수(파라미터가 없는 public, protected 생성자) - 스펙상 설정
- nullable을 false로 설정 시 해당 컬럼에 대한 not null 설정이 됨

4-1 @Enumerated
- ordinal : 순서를 DB에 저장(권장x)
	* Enum에 값을 추가하게 되면 DB에 저장되어 있는 순서와 상과없이 순서가 재배치됨
	* 순서가 재배치되면서 실제 값과 DB의 순서와 일치하지 않는 현상이 발생
- string: 이름을 DB에 저장
